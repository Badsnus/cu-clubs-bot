// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"

	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/club"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/clubowner"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/event"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/eventparticipant"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/ignoremailing"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/notification"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/pass"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/predicate"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/adapters/secondary/postgres/ent/user"
	"github.com/Badsnus/cu-clubs-bot/bot/internal/domain/valueobject"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClub             = "Club"
	TypeClubOwner        = "ClubOwner"
	TypeEvent            = "Event"
	TypeEventParticipant = "EventParticipant"
	TypeIgnoreMailing    = "IgnoreMailing"
	TypeNotification     = "Notification"
	TypePass             = "Pass"
	TypeUser             = "User"
)

// ClubMutation represents an operation that mutates the Club nodes in the graph.
type ClubMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	deleted_at             *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	name                   *string
	description            *string
	link                   *string
	avatar_id              *string
	intro_id               *string
	visible_in_tour        *bool
	allowed_roles          *valueobject.Roles
	appendallowed_roles    valueobject.Roles
	qr_allowed             *bool
	clearedFields          map[string]struct{}
	events                 map[uuid.UUID]struct{}
	removedevents          map[uuid.UUID]struct{}
	clearedevents          bool
	owners                 map[uuid.UUID]struct{}
	removedowners          map[uuid.UUID]struct{}
	clearedowners          bool
	ignore_mailings        map[uuid.UUID]struct{}
	removedignore_mailings map[uuid.UUID]struct{}
	clearedignore_mailings bool
	club_owners            map[uuid.UUID]struct{}
	removedclub_owners     map[uuid.UUID]struct{}
	clearedclub_owners     bool
	done                   bool
	oldValue               func(context.Context) (*Club, error)
	predicates             []predicate.Club
}

var _ ent.Mutation = (*ClubMutation)(nil)

// clubOption allows management of the mutation configuration using functional options.
type clubOption func(*ClubMutation)

// newClubMutation creates new mutation for the Club entity.
func newClubMutation(c config, op Op, opts ...clubOption) *ClubMutation {
	m := &ClubMutation{
		config:        c,
		op:            op,
		typ:           TypeClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubID sets the ID field of the mutation.
func withClubID(id uuid.UUID) clubOption {
	return func(m *ClubMutation) {
		var (
			err   error
			once  sync.Once
			value *Club
		)
		m.oldValue = func(ctx context.Context) (*Club, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Club.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClub sets the old Club of the mutation.
func withClub(node *Club) clubOption {
	return func(m *ClubMutation) {
		m.oldValue = func(context.Context) (*Club, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Club entities.
func (m *ClubMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClubMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Club.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ClubMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ClubMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ClubMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[club.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ClubMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[club.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ClubMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, club.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClubMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClubMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClubMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClubMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClubMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClubMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ClubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClubMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ClubMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClubMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ClubMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[club.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ClubMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[club.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ClubMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, club.FieldDescription)
}

// SetLink sets the "link" field.
func (m *ClubMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *ClubMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *ClubMutation) ClearLink() {
	m.link = nil
	m.clearedFields[club.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *ClubMutation) LinkCleared() bool {
	_, ok := m.clearedFields[club.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *ClubMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, club.FieldLink)
}

// SetAvatarID sets the "avatar_id" field.
func (m *ClubMutation) SetAvatarID(s string) {
	m.avatar_id = &s
}

// AvatarID returns the value of the "avatar_id" field in the mutation.
func (m *ClubMutation) AvatarID() (r string, exists bool) {
	v := m.avatar_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarID returns the old "avatar_id" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldAvatarID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarID: %w", err)
	}
	return oldValue.AvatarID, nil
}

// ClearAvatarID clears the value of the "avatar_id" field.
func (m *ClubMutation) ClearAvatarID() {
	m.avatar_id = nil
	m.clearedFields[club.FieldAvatarID] = struct{}{}
}

// AvatarIDCleared returns if the "avatar_id" field was cleared in this mutation.
func (m *ClubMutation) AvatarIDCleared() bool {
	_, ok := m.clearedFields[club.FieldAvatarID]
	return ok
}

// ResetAvatarID resets all changes to the "avatar_id" field.
func (m *ClubMutation) ResetAvatarID() {
	m.avatar_id = nil
	delete(m.clearedFields, club.FieldAvatarID)
}

// SetIntroID sets the "intro_id" field.
func (m *ClubMutation) SetIntroID(s string) {
	m.intro_id = &s
}

// IntroID returns the value of the "intro_id" field in the mutation.
func (m *ClubMutation) IntroID() (r string, exists bool) {
	v := m.intro_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroID returns the old "intro_id" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldIntroID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroID: %w", err)
	}
	return oldValue.IntroID, nil
}

// ClearIntroID clears the value of the "intro_id" field.
func (m *ClubMutation) ClearIntroID() {
	m.intro_id = nil
	m.clearedFields[club.FieldIntroID] = struct{}{}
}

// IntroIDCleared returns if the "intro_id" field was cleared in this mutation.
func (m *ClubMutation) IntroIDCleared() bool {
	_, ok := m.clearedFields[club.FieldIntroID]
	return ok
}

// ResetIntroID resets all changes to the "intro_id" field.
func (m *ClubMutation) ResetIntroID() {
	m.intro_id = nil
	delete(m.clearedFields, club.FieldIntroID)
}

// SetVisibleInTour sets the "visible_in_tour" field.
func (m *ClubMutation) SetVisibleInTour(b bool) {
	m.visible_in_tour = &b
}

// VisibleInTour returns the value of the "visible_in_tour" field in the mutation.
func (m *ClubMutation) VisibleInTour() (r bool, exists bool) {
	v := m.visible_in_tour
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleInTour returns the old "visible_in_tour" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldVisibleInTour(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleInTour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleInTour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleInTour: %w", err)
	}
	return oldValue.VisibleInTour, nil
}

// ResetVisibleInTour resets all changes to the "visible_in_tour" field.
func (m *ClubMutation) ResetVisibleInTour() {
	m.visible_in_tour = nil
}

// SetAllowedRoles sets the "allowed_roles" field.
func (m *ClubMutation) SetAllowedRoles(v valueobject.Roles) {
	m.allowed_roles = &v
	m.appendallowed_roles = nil
}

// AllowedRoles returns the value of the "allowed_roles" field in the mutation.
func (m *ClubMutation) AllowedRoles() (r valueobject.Roles, exists bool) {
	v := m.allowed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRoles returns the old "allowed_roles" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldAllowedRoles(ctx context.Context) (v valueobject.Roles, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRoles: %w", err)
	}
	return oldValue.AllowedRoles, nil
}

// AppendAllowedRoles adds v to the "allowed_roles" field.
func (m *ClubMutation) AppendAllowedRoles(v valueobject.Roles) {
	m.appendallowed_roles = append(m.appendallowed_roles, v...)
}

// AppendedAllowedRoles returns the list of values that were appended to the "allowed_roles" field in this mutation.
func (m *ClubMutation) AppendedAllowedRoles() (valueobject.Roles, bool) {
	if len(m.appendallowed_roles) == 0 {
		return nil, false
	}
	return m.appendallowed_roles, true
}

// ClearAllowedRoles clears the value of the "allowed_roles" field.
func (m *ClubMutation) ClearAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
	m.clearedFields[club.FieldAllowedRoles] = struct{}{}
}

// AllowedRolesCleared returns if the "allowed_roles" field was cleared in this mutation.
func (m *ClubMutation) AllowedRolesCleared() bool {
	_, ok := m.clearedFields[club.FieldAllowedRoles]
	return ok
}

// ResetAllowedRoles resets all changes to the "allowed_roles" field.
func (m *ClubMutation) ResetAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
	delete(m.clearedFields, club.FieldAllowedRoles)
}

// SetQrAllowed sets the "qr_allowed" field.
func (m *ClubMutation) SetQrAllowed(b bool) {
	m.qr_allowed = &b
}

// QrAllowed returns the value of the "qr_allowed" field in the mutation.
func (m *ClubMutation) QrAllowed() (r bool, exists bool) {
	v := m.qr_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldQrAllowed returns the old "qr_allowed" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldQrAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrAllowed: %w", err)
	}
	return oldValue.QrAllowed, nil
}

// ResetQrAllowed resets all changes to the "qr_allowed" field.
func (m *ClubMutation) ResetQrAllowed() {
	m.qr_allowed = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *ClubMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *ClubMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *ClubMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *ClubMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *ClubMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ClubMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ClubMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddOwnerIDs adds the "owners" edge to the User entity by ids.
func (m *ClubMutation) AddOwnerIDs(ids ...uuid.UUID) {
	if m.owners == nil {
		m.owners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.owners[ids[i]] = struct{}{}
	}
}

// ClearOwners clears the "owners" edge to the User entity.
func (m *ClubMutation) ClearOwners() {
	m.clearedowners = true
}

// OwnersCleared reports if the "owners" edge to the User entity was cleared.
func (m *ClubMutation) OwnersCleared() bool {
	return m.clearedowners
}

// RemoveOwnerIDs removes the "owners" edge to the User entity by IDs.
func (m *ClubMutation) RemoveOwnerIDs(ids ...uuid.UUID) {
	if m.removedowners == nil {
		m.removedowners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.owners, ids[i])
		m.removedowners[ids[i]] = struct{}{}
	}
}

// RemovedOwners returns the removed IDs of the "owners" edge to the User entity.
func (m *ClubMutation) RemovedOwnersIDs() (ids []uuid.UUID) {
	for id := range m.removedowners {
		ids = append(ids, id)
	}
	return
}

// OwnersIDs returns the "owners" edge IDs in the mutation.
func (m *ClubMutation) OwnersIDs() (ids []uuid.UUID) {
	for id := range m.owners {
		ids = append(ids, id)
	}
	return
}

// ResetOwners resets all changes to the "owners" edge.
func (m *ClubMutation) ResetOwners() {
	m.owners = nil
	m.clearedowners = false
	m.removedowners = nil
}

// AddIgnoreMailingIDs adds the "ignore_mailings" edge to the IgnoreMailing entity by ids.
func (m *ClubMutation) AddIgnoreMailingIDs(ids ...uuid.UUID) {
	if m.ignore_mailings == nil {
		m.ignore_mailings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ignore_mailings[ids[i]] = struct{}{}
	}
}

// ClearIgnoreMailings clears the "ignore_mailings" edge to the IgnoreMailing entity.
func (m *ClubMutation) ClearIgnoreMailings() {
	m.clearedignore_mailings = true
}

// IgnoreMailingsCleared reports if the "ignore_mailings" edge to the IgnoreMailing entity was cleared.
func (m *ClubMutation) IgnoreMailingsCleared() bool {
	return m.clearedignore_mailings
}

// RemoveIgnoreMailingIDs removes the "ignore_mailings" edge to the IgnoreMailing entity by IDs.
func (m *ClubMutation) RemoveIgnoreMailingIDs(ids ...uuid.UUID) {
	if m.removedignore_mailings == nil {
		m.removedignore_mailings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ignore_mailings, ids[i])
		m.removedignore_mailings[ids[i]] = struct{}{}
	}
}

// RemovedIgnoreMailings returns the removed IDs of the "ignore_mailings" edge to the IgnoreMailing entity.
func (m *ClubMutation) RemovedIgnoreMailingsIDs() (ids []uuid.UUID) {
	for id := range m.removedignore_mailings {
		ids = append(ids, id)
	}
	return
}

// IgnoreMailingsIDs returns the "ignore_mailings" edge IDs in the mutation.
func (m *ClubMutation) IgnoreMailingsIDs() (ids []uuid.UUID) {
	for id := range m.ignore_mailings {
		ids = append(ids, id)
	}
	return
}

// ResetIgnoreMailings resets all changes to the "ignore_mailings" edge.
func (m *ClubMutation) ResetIgnoreMailings() {
	m.ignore_mailings = nil
	m.clearedignore_mailings = false
	m.removedignore_mailings = nil
}

// AddClubOwnerIDs adds the "club_owners" edge to the ClubOwner entity by ids.
func (m *ClubMutation) AddClubOwnerIDs(ids ...uuid.UUID) {
	if m.club_owners == nil {
		m.club_owners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.club_owners[ids[i]] = struct{}{}
	}
}

// ClearClubOwners clears the "club_owners" edge to the ClubOwner entity.
func (m *ClubMutation) ClearClubOwners() {
	m.clearedclub_owners = true
}

// ClubOwnersCleared reports if the "club_owners" edge to the ClubOwner entity was cleared.
func (m *ClubMutation) ClubOwnersCleared() bool {
	return m.clearedclub_owners
}

// RemoveClubOwnerIDs removes the "club_owners" edge to the ClubOwner entity by IDs.
func (m *ClubMutation) RemoveClubOwnerIDs(ids ...uuid.UUID) {
	if m.removedclub_owners == nil {
		m.removedclub_owners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.club_owners, ids[i])
		m.removedclub_owners[ids[i]] = struct{}{}
	}
}

// RemovedClubOwners returns the removed IDs of the "club_owners" edge to the ClubOwner entity.
func (m *ClubMutation) RemovedClubOwnersIDs() (ids []uuid.UUID) {
	for id := range m.removedclub_owners {
		ids = append(ids, id)
	}
	return
}

// ClubOwnersIDs returns the "club_owners" edge IDs in the mutation.
func (m *ClubMutation) ClubOwnersIDs() (ids []uuid.UUID) {
	for id := range m.club_owners {
		ids = append(ids, id)
	}
	return
}

// ResetClubOwners resets all changes to the "club_owners" edge.
func (m *ClubMutation) ResetClubOwners() {
	m.club_owners = nil
	m.clearedclub_owners = false
	m.removedclub_owners = nil
}

// Where appends a list predicates to the ClubMutation builder.
func (m *ClubMutation) Where(ps ...predicate.Club) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClubMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClubMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Club, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClubMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClubMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Club).
func (m *ClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.deleted_at != nil {
		fields = append(fields, club.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, club.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, club.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, club.FieldName)
	}
	if m.description != nil {
		fields = append(fields, club.FieldDescription)
	}
	if m.link != nil {
		fields = append(fields, club.FieldLink)
	}
	if m.avatar_id != nil {
		fields = append(fields, club.FieldAvatarID)
	}
	if m.intro_id != nil {
		fields = append(fields, club.FieldIntroID)
	}
	if m.visible_in_tour != nil {
		fields = append(fields, club.FieldVisibleInTour)
	}
	if m.allowed_roles != nil {
		fields = append(fields, club.FieldAllowedRoles)
	}
	if m.qr_allowed != nil {
		fields = append(fields, club.FieldQrAllowed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case club.FieldDeletedAt:
		return m.DeletedAt()
	case club.FieldCreatedAt:
		return m.CreatedAt()
	case club.FieldUpdatedAt:
		return m.UpdatedAt()
	case club.FieldName:
		return m.Name()
	case club.FieldDescription:
		return m.Description()
	case club.FieldLink:
		return m.Link()
	case club.FieldAvatarID:
		return m.AvatarID()
	case club.FieldIntroID:
		return m.IntroID()
	case club.FieldVisibleInTour:
		return m.VisibleInTour()
	case club.FieldAllowedRoles:
		return m.AllowedRoles()
	case club.FieldQrAllowed:
		return m.QrAllowed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case club.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case club.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case club.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case club.FieldName:
		return m.OldName(ctx)
	case club.FieldDescription:
		return m.OldDescription(ctx)
	case club.FieldLink:
		return m.OldLink(ctx)
	case club.FieldAvatarID:
		return m.OldAvatarID(ctx)
	case club.FieldIntroID:
		return m.OldIntroID(ctx)
	case club.FieldVisibleInTour:
		return m.OldVisibleInTour(ctx)
	case club.FieldAllowedRoles:
		return m.OldAllowedRoles(ctx)
	case club.FieldQrAllowed:
		return m.OldQrAllowed(ctx)
	}
	return nil, fmt.Errorf("unknown Club field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case club.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case club.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case club.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case club.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case club.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case club.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case club.FieldAvatarID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarID(v)
		return nil
	case club.FieldIntroID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroID(v)
		return nil
	case club.FieldVisibleInTour:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleInTour(v)
		return nil
	case club.FieldAllowedRoles:
		v, ok := value.(valueobject.Roles)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRoles(v)
		return nil
	case club.FieldQrAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrAllowed(v)
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Club numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(club.FieldDeletedAt) {
		fields = append(fields, club.FieldDeletedAt)
	}
	if m.FieldCleared(club.FieldDescription) {
		fields = append(fields, club.FieldDescription)
	}
	if m.FieldCleared(club.FieldLink) {
		fields = append(fields, club.FieldLink)
	}
	if m.FieldCleared(club.FieldAvatarID) {
		fields = append(fields, club.FieldAvatarID)
	}
	if m.FieldCleared(club.FieldIntroID) {
		fields = append(fields, club.FieldIntroID)
	}
	if m.FieldCleared(club.FieldAllowedRoles) {
		fields = append(fields, club.FieldAllowedRoles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMutation) ClearField(name string) error {
	switch name {
	case club.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case club.FieldDescription:
		m.ClearDescription()
		return nil
	case club.FieldLink:
		m.ClearLink()
		return nil
	case club.FieldAvatarID:
		m.ClearAvatarID()
		return nil
	case club.FieldIntroID:
		m.ClearIntroID()
		return nil
	case club.FieldAllowedRoles:
		m.ClearAllowedRoles()
		return nil
	}
	return fmt.Errorf("unknown Club nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMutation) ResetField(name string) error {
	switch name {
	case club.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case club.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case club.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case club.FieldName:
		m.ResetName()
		return nil
	case club.FieldDescription:
		m.ResetDescription()
		return nil
	case club.FieldLink:
		m.ResetLink()
		return nil
	case club.FieldAvatarID:
		m.ResetAvatarID()
		return nil
	case club.FieldIntroID:
		m.ResetIntroID()
		return nil
	case club.FieldVisibleInTour:
		m.ResetVisibleInTour()
		return nil
	case club.FieldAllowedRoles:
		m.ResetAllowedRoles()
		return nil
	case club.FieldQrAllowed:
		m.ResetQrAllowed()
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.events != nil {
		edges = append(edges, club.EdgeEvents)
	}
	if m.owners != nil {
		edges = append(edges, club.EdgeOwners)
	}
	if m.ignore_mailings != nil {
		edges = append(edges, club.EdgeIgnoreMailings)
	}
	if m.club_owners != nil {
		edges = append(edges, club.EdgeClubOwners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.owners))
		for id := range m.owners {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeIgnoreMailings:
		ids := make([]ent.Value, 0, len(m.ignore_mailings))
		for id := range m.ignore_mailings {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeClubOwners:
		ids := make([]ent.Value, 0, len(m.club_owners))
		for id := range m.club_owners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedevents != nil {
		edges = append(edges, club.EdgeEvents)
	}
	if m.removedowners != nil {
		edges = append(edges, club.EdgeOwners)
	}
	if m.removedignore_mailings != nil {
		edges = append(edges, club.EdgeIgnoreMailings)
	}
	if m.removedclub_owners != nil {
		edges = append(edges, club.EdgeClubOwners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.removedowners))
		for id := range m.removedowners {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeIgnoreMailings:
		ids := make([]ent.Value, 0, len(m.removedignore_mailings))
		for id := range m.removedignore_mailings {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeClubOwners:
		ids := make([]ent.Value, 0, len(m.removedclub_owners))
		for id := range m.removedclub_owners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedevents {
		edges = append(edges, club.EdgeEvents)
	}
	if m.clearedowners {
		edges = append(edges, club.EdgeOwners)
	}
	if m.clearedignore_mailings {
		edges = append(edges, club.EdgeIgnoreMailings)
	}
	if m.clearedclub_owners {
		edges = append(edges, club.EdgeClubOwners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMutation) EdgeCleared(name string) bool {
	switch name {
	case club.EdgeEvents:
		return m.clearedevents
	case club.EdgeOwners:
		return m.clearedowners
	case club.EdgeIgnoreMailings:
		return m.clearedignore_mailings
	case club.EdgeClubOwners:
		return m.clearedclub_owners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Club unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMutation) ResetEdge(name string) error {
	switch name {
	case club.EdgeEvents:
		m.ResetEvents()
		return nil
	case club.EdgeOwners:
		m.ResetOwners()
		return nil
	case club.EdgeIgnoreMailings:
		m.ResetIgnoreMailings()
		return nil
	case club.EdgeClubOwners:
		m.ResetClubOwners()
		return nil
	}
	return fmt.Errorf("unknown Club edge %s", name)
}

// ClubOwnerMutation represents an operation that mutates the ClubOwner nodes in the graph.
type ClubOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	warnings      *bool
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	club          *uuid.UUID
	clearedclub   bool
	done          bool
	oldValue      func(context.Context) (*ClubOwner, error)
	predicates    []predicate.ClubOwner
}

var _ ent.Mutation = (*ClubOwnerMutation)(nil)

// clubownerOption allows management of the mutation configuration using functional options.
type clubownerOption func(*ClubOwnerMutation)

// newClubOwnerMutation creates new mutation for the ClubOwner entity.
func newClubOwnerMutation(c config, op Op, opts ...clubownerOption) *ClubOwnerMutation {
	m := &ClubOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeClubOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubOwnerID sets the ID field of the mutation.
func withClubOwnerID(id uuid.UUID) clubownerOption {
	return func(m *ClubOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubOwner
		)
		m.oldValue = func(ctx context.Context) (*ClubOwner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubOwner sets the old ClubOwner of the mutation.
func withClubOwner(node *ClubOwner) clubownerOption {
	return func(m *ClubOwnerMutation) {
		m.oldValue = func(context.Context) (*ClubOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClubOwner entities.
func (m *ClubOwnerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubOwnerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClubOwnerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClubOwner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ClubOwnerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ClubOwnerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ClubOwnerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[clubowner.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ClubOwnerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[clubowner.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ClubOwnerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, clubowner.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClubOwnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClubOwnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClubOwnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClubOwnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClubOwnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClubOwnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ClubOwnerMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ClubOwnerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ClubOwnerMutation) ResetUserID() {
	m.user = nil
}

// SetClubID sets the "club_id" field.
func (m *ClubOwnerMutation) SetClubID(u uuid.UUID) {
	m.club = &u
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *ClubOwnerMutation) ClubID() (r uuid.UUID, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldClubID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *ClubOwnerMutation) ResetClubID() {
	m.club = nil
}

// SetWarnings sets the "warnings" field.
func (m *ClubOwnerMutation) SetWarnings(b bool) {
	m.warnings = &b
}

// Warnings returns the value of the "warnings" field in the mutation.
func (m *ClubOwnerMutation) Warnings() (r bool, exists bool) {
	v := m.warnings
	if v == nil {
		return
	}
	return *v, true
}

// OldWarnings returns the old "warnings" field's value of the ClubOwner entity.
// If the ClubOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubOwnerMutation) OldWarnings(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarnings: %w", err)
	}
	return oldValue.Warnings, nil
}

// ResetWarnings resets all changes to the "warnings" field.
func (m *ClubOwnerMutation) ResetWarnings() {
	m.warnings = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClubOwnerMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[clubowner.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClubOwnerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClubOwnerMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClubOwnerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearClub clears the "club" edge to the Club entity.
func (m *ClubOwnerMutation) ClearClub() {
	m.clearedclub = true
	m.clearedFields[clubowner.FieldClubID] = struct{}{}
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *ClubOwnerMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ClubOwnerMutation) ClubIDs() (ids []uuid.UUID) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *ClubOwnerMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// Where appends a list predicates to the ClubOwnerMutation builder.
func (m *ClubOwnerMutation) Where(ps ...predicate.ClubOwner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClubOwnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClubOwnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClubOwner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClubOwnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClubOwnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClubOwner).
func (m *ClubOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubOwnerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, clubowner.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, clubowner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clubowner.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, clubowner.FieldUserID)
	}
	if m.club != nil {
		fields = append(fields, clubowner.FieldClubID)
	}
	if m.warnings != nil {
		fields = append(fields, clubowner.FieldWarnings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubowner.FieldDeletedAt:
		return m.DeletedAt()
	case clubowner.FieldCreatedAt:
		return m.CreatedAt()
	case clubowner.FieldUpdatedAt:
		return m.UpdatedAt()
	case clubowner.FieldUserID:
		return m.UserID()
	case clubowner.FieldClubID:
		return m.ClubID()
	case clubowner.FieldWarnings:
		return m.Warnings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubowner.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case clubowner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clubowner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clubowner.FieldUserID:
		return m.OldUserID(ctx)
	case clubowner.FieldClubID:
		return m.OldClubID(ctx)
	case clubowner.FieldWarnings:
		return m.OldWarnings(ctx)
	}
	return nil, fmt.Errorf("unknown ClubOwner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubowner.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case clubowner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clubowner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clubowner.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case clubowner.FieldClubID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	case clubowner.FieldWarnings:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarnings(v)
		return nil
	}
	return fmt.Errorf("unknown ClubOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubOwnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubOwnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubOwnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clubowner.FieldDeletedAt) {
		fields = append(fields, clubowner.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubOwnerMutation) ClearField(name string) error {
	switch name {
	case clubowner.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ClubOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubOwnerMutation) ResetField(name string) error {
	switch name {
	case clubowner.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case clubowner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clubowner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clubowner.FieldUserID:
		m.ResetUserID()
		return nil
	case clubowner.FieldClubID:
		m.ResetClubID()
		return nil
	case clubowner.FieldWarnings:
		m.ResetWarnings()
		return nil
	}
	return fmt.Errorf("unknown ClubOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, clubowner.EdgeUser)
	}
	if m.club != nil {
		edges = append(edges, clubowner.EdgeClub)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubOwnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubowner.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case clubowner.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubOwnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, clubowner.EdgeUser)
	}
	if m.clearedclub {
		edges = append(edges, clubowner.EdgeClub)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubOwnerMutation) EdgeCleared(name string) bool {
	switch name {
	case clubowner.EdgeUser:
		return m.cleareduser
	case clubowner.EdgeClub:
		return m.clearedclub
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubOwnerMutation) ClearEdge(name string) error {
	switch name {
	case clubowner.EdgeUser:
		m.ClearUser()
		return nil
	case clubowner.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown ClubOwner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubOwnerMutation) ResetEdge(name string) error {
	switch name {
	case clubowner.EdgeUser:
		m.ResetUser()
		return nil
	case clubowner.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown ClubOwner edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	deleted_at                *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	name                      *string
	description               *string
	after_registration_text   *string
	location                  *string
	start_time                *time.Time
	end_time                  *time.Time
	registration_end_time     *time.Time
	max_participants          *int
	addmax_participants       *int
	expected_participants     *int
	addexpected_participants  *int
	qr_payload                *uuid.UUID
	qr_file_id                *string
	allowed_roles             *valueobject.Roles
	appendallowed_roles       valueobject.Roles
	pass_required             *bool
	clearedFields             map[string]struct{}
	club                      *uuid.UUID
	clearedclub               bool
	participants              map[uuid.UUID]struct{}
	removedparticipants       map[uuid.UUID]struct{}
	clearedparticipants       bool
	notifications             map[uuid.UUID]struct{}
	removednotifications      map[uuid.UUID]struct{}
	clearednotifications      bool
	passes                    map[uuid.UUID]struct{}
	removedpasses             map[uuid.UUID]struct{}
	clearedpasses             bool
	event_participants        map[uuid.UUID]struct{}
	removedevent_participants map[uuid.UUID]struct{}
	clearedevent_participants bool
	done                      bool
	oldValue                  func(context.Context) (*Event, error)
	predicates                []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClubID sets the "club_id" field.
func (m *EventMutation) SetClubID(u uuid.UUID) {
	m.club = &u
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *EventMutation) ClubID() (r uuid.UUID, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldClubID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *EventMutation) ResetClubID() {
	m.club = nil
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetAfterRegistrationText sets the "after_registration_text" field.
func (m *EventMutation) SetAfterRegistrationText(s string) {
	m.after_registration_text = &s
}

// AfterRegistrationText returns the value of the "after_registration_text" field in the mutation.
func (m *EventMutation) AfterRegistrationText() (r string, exists bool) {
	v := m.after_registration_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterRegistrationText returns the old "after_registration_text" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAfterRegistrationText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterRegistrationText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterRegistrationText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterRegistrationText: %w", err)
	}
	return oldValue.AfterRegistrationText, nil
}

// ClearAfterRegistrationText clears the value of the "after_registration_text" field.
func (m *EventMutation) ClearAfterRegistrationText() {
	m.after_registration_text = nil
	m.clearedFields[event.FieldAfterRegistrationText] = struct{}{}
}

// AfterRegistrationTextCleared returns if the "after_registration_text" field was cleared in this mutation.
func (m *EventMutation) AfterRegistrationTextCleared() bool {
	_, ok := m.clearedFields[event.FieldAfterRegistrationText]
	return ok
}

// ResetAfterRegistrationText resets all changes to the "after_registration_text" field.
func (m *EventMutation) ResetAfterRegistrationText() {
	m.after_registration_text = nil
	delete(m.clearedFields, event.FieldAfterRegistrationText)
}

// SetLocation sets the "location" field.
func (m *EventMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EventMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *EventMutation) ResetLocation() {
	m.location = nil
}

// SetStartTime sets the "start_time" field.
func (m *EventMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *EventMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *EventMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *EventMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *EventMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *EventMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[event.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *EventMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *EventMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, event.FieldEndTime)
}

// SetRegistrationEndTime sets the "registration_end_time" field.
func (m *EventMutation) SetRegistrationEndTime(t time.Time) {
	m.registration_end_time = &t
}

// RegistrationEndTime returns the value of the "registration_end_time" field in the mutation.
func (m *EventMutation) RegistrationEndTime() (r time.Time, exists bool) {
	v := m.registration_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationEndTime returns the old "registration_end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationEndTime: %w", err)
	}
	return oldValue.RegistrationEndTime, nil
}

// ResetRegistrationEndTime resets all changes to the "registration_end_time" field.
func (m *EventMutation) ResetRegistrationEndTime() {
	m.registration_end_time = nil
}

// SetMaxParticipants sets the "max_participants" field.
func (m *EventMutation) SetMaxParticipants(i int) {
	m.max_participants = &i
	m.addmax_participants = nil
}

// MaxParticipants returns the value of the "max_participants" field in the mutation.
func (m *EventMutation) MaxParticipants() (r int, exists bool) {
	v := m.max_participants
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxParticipants returns the old "max_participants" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMaxParticipants(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxParticipants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxParticipants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxParticipants: %w", err)
	}
	return oldValue.MaxParticipants, nil
}

// AddMaxParticipants adds i to the "max_participants" field.
func (m *EventMutation) AddMaxParticipants(i int) {
	if m.addmax_participants != nil {
		*m.addmax_participants += i
	} else {
		m.addmax_participants = &i
	}
}

// AddedMaxParticipants returns the value that was added to the "max_participants" field in this mutation.
func (m *EventMutation) AddedMaxParticipants() (r int, exists bool) {
	v := m.addmax_participants
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxParticipants clears the value of the "max_participants" field.
func (m *EventMutation) ClearMaxParticipants() {
	m.max_participants = nil
	m.addmax_participants = nil
	m.clearedFields[event.FieldMaxParticipants] = struct{}{}
}

// MaxParticipantsCleared returns if the "max_participants" field was cleared in this mutation.
func (m *EventMutation) MaxParticipantsCleared() bool {
	_, ok := m.clearedFields[event.FieldMaxParticipants]
	return ok
}

// ResetMaxParticipants resets all changes to the "max_participants" field.
func (m *EventMutation) ResetMaxParticipants() {
	m.max_participants = nil
	m.addmax_participants = nil
	delete(m.clearedFields, event.FieldMaxParticipants)
}

// SetExpectedParticipants sets the "expected_participants" field.
func (m *EventMutation) SetExpectedParticipants(i int) {
	m.expected_participants = &i
	m.addexpected_participants = nil
}

// ExpectedParticipants returns the value of the "expected_participants" field in the mutation.
func (m *EventMutation) ExpectedParticipants() (r int, exists bool) {
	v := m.expected_participants
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedParticipants returns the old "expected_participants" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldExpectedParticipants(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedParticipants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedParticipants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedParticipants: %w", err)
	}
	return oldValue.ExpectedParticipants, nil
}

// AddExpectedParticipants adds i to the "expected_participants" field.
func (m *EventMutation) AddExpectedParticipants(i int) {
	if m.addexpected_participants != nil {
		*m.addexpected_participants += i
	} else {
		m.addexpected_participants = &i
	}
}

// AddedExpectedParticipants returns the value that was added to the "expected_participants" field in this mutation.
func (m *EventMutation) AddedExpectedParticipants() (r int, exists bool) {
	v := m.addexpected_participants
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpectedParticipants clears the value of the "expected_participants" field.
func (m *EventMutation) ClearExpectedParticipants() {
	m.expected_participants = nil
	m.addexpected_participants = nil
	m.clearedFields[event.FieldExpectedParticipants] = struct{}{}
}

// ExpectedParticipantsCleared returns if the "expected_participants" field was cleared in this mutation.
func (m *EventMutation) ExpectedParticipantsCleared() bool {
	_, ok := m.clearedFields[event.FieldExpectedParticipants]
	return ok
}

// ResetExpectedParticipants resets all changes to the "expected_participants" field.
func (m *EventMutation) ResetExpectedParticipants() {
	m.expected_participants = nil
	m.addexpected_participants = nil
	delete(m.clearedFields, event.FieldExpectedParticipants)
}

// SetQrPayload sets the "qr_payload" field.
func (m *EventMutation) SetQrPayload(u uuid.UUID) {
	m.qr_payload = &u
}

// QrPayload returns the value of the "qr_payload" field in the mutation.
func (m *EventMutation) QrPayload() (r uuid.UUID, exists bool) {
	v := m.qr_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldQrPayload returns the old "qr_payload" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldQrPayload(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrPayload: %w", err)
	}
	return oldValue.QrPayload, nil
}

// ClearQrPayload clears the value of the "qr_payload" field.
func (m *EventMutation) ClearQrPayload() {
	m.qr_payload = nil
	m.clearedFields[event.FieldQrPayload] = struct{}{}
}

// QrPayloadCleared returns if the "qr_payload" field was cleared in this mutation.
func (m *EventMutation) QrPayloadCleared() bool {
	_, ok := m.clearedFields[event.FieldQrPayload]
	return ok
}

// ResetQrPayload resets all changes to the "qr_payload" field.
func (m *EventMutation) ResetQrPayload() {
	m.qr_payload = nil
	delete(m.clearedFields, event.FieldQrPayload)
}

// SetQrFileID sets the "qr_file_id" field.
func (m *EventMutation) SetQrFileID(s string) {
	m.qr_file_id = &s
}

// QrFileID returns the value of the "qr_file_id" field in the mutation.
func (m *EventMutation) QrFileID() (r string, exists bool) {
	v := m.qr_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQrFileID returns the old "qr_file_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldQrFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrFileID: %w", err)
	}
	return oldValue.QrFileID, nil
}

// ClearQrFileID clears the value of the "qr_file_id" field.
func (m *EventMutation) ClearQrFileID() {
	m.qr_file_id = nil
	m.clearedFields[event.FieldQrFileID] = struct{}{}
}

// QrFileIDCleared returns if the "qr_file_id" field was cleared in this mutation.
func (m *EventMutation) QrFileIDCleared() bool {
	_, ok := m.clearedFields[event.FieldQrFileID]
	return ok
}

// ResetQrFileID resets all changes to the "qr_file_id" field.
func (m *EventMutation) ResetQrFileID() {
	m.qr_file_id = nil
	delete(m.clearedFields, event.FieldQrFileID)
}

// SetAllowedRoles sets the "allowed_roles" field.
func (m *EventMutation) SetAllowedRoles(v valueobject.Roles) {
	m.allowed_roles = &v
	m.appendallowed_roles = nil
}

// AllowedRoles returns the value of the "allowed_roles" field in the mutation.
func (m *EventMutation) AllowedRoles() (r valueobject.Roles, exists bool) {
	v := m.allowed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRoles returns the old "allowed_roles" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAllowedRoles(ctx context.Context) (v valueobject.Roles, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRoles: %w", err)
	}
	return oldValue.AllowedRoles, nil
}

// AppendAllowedRoles adds v to the "allowed_roles" field.
func (m *EventMutation) AppendAllowedRoles(v valueobject.Roles) {
	m.appendallowed_roles = append(m.appendallowed_roles, v...)
}

// AppendedAllowedRoles returns the list of values that were appended to the "allowed_roles" field in this mutation.
func (m *EventMutation) AppendedAllowedRoles() (valueobject.Roles, bool) {
	if len(m.appendallowed_roles) == 0 {
		return nil, false
	}
	return m.appendallowed_roles, true
}

// ClearAllowedRoles clears the value of the "allowed_roles" field.
func (m *EventMutation) ClearAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
	m.clearedFields[event.FieldAllowedRoles] = struct{}{}
}

// AllowedRolesCleared returns if the "allowed_roles" field was cleared in this mutation.
func (m *EventMutation) AllowedRolesCleared() bool {
	_, ok := m.clearedFields[event.FieldAllowedRoles]
	return ok
}

// ResetAllowedRoles resets all changes to the "allowed_roles" field.
func (m *EventMutation) ResetAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
	delete(m.clearedFields, event.FieldAllowedRoles)
}

// SetPassRequired sets the "pass_required" field.
func (m *EventMutation) SetPassRequired(b bool) {
	m.pass_required = &b
}

// PassRequired returns the value of the "pass_required" field in the mutation.
func (m *EventMutation) PassRequired() (r bool, exists bool) {
	v := m.pass_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPassRequired returns the old "pass_required" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldPassRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassRequired: %w", err)
	}
	return oldValue.PassRequired, nil
}

// ResetPassRequired resets all changes to the "pass_required" field.
func (m *EventMutation) ResetPassRequired() {
	m.pass_required = nil
}

// ClearClub clears the "club" edge to the Club entity.
func (m *EventMutation) ClearClub() {
	m.clearedclub = true
	m.clearedFields[event.FieldClubID] = struct{}{}
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *EventMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ClubIDs() (ids []uuid.UUID) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *EventMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// AddParticipantIDs adds the "participants" edge to the User entity by ids.
func (m *EventMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the User entity.
func (m *EventMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the User entity was cleared.
func (m *EventMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the User entity by IDs.
func (m *EventMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the User entity.
func (m *EventMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *EventMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *EventMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *EventMutation) AddNotificationIDs(ids ...uuid.UUID) {
	if m.notifications == nil {
		m.notifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *EventMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *EventMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *EventMutation) RemoveNotificationIDs(ids ...uuid.UUID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *EventMutation) RemovedNotificationsIDs() (ids []uuid.UUID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *EventMutation) NotificationsIDs() (ids []uuid.UUID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *EventMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddPassIDs adds the "passes" edge to the Pass entity by ids.
func (m *EventMutation) AddPassIDs(ids ...uuid.UUID) {
	if m.passes == nil {
		m.passes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.passes[ids[i]] = struct{}{}
	}
}

// ClearPasses clears the "passes" edge to the Pass entity.
func (m *EventMutation) ClearPasses() {
	m.clearedpasses = true
}

// PassesCleared reports if the "passes" edge to the Pass entity was cleared.
func (m *EventMutation) PassesCleared() bool {
	return m.clearedpasses
}

// RemovePassIDs removes the "passes" edge to the Pass entity by IDs.
func (m *EventMutation) RemovePassIDs(ids ...uuid.UUID) {
	if m.removedpasses == nil {
		m.removedpasses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.passes, ids[i])
		m.removedpasses[ids[i]] = struct{}{}
	}
}

// RemovedPasses returns the removed IDs of the "passes" edge to the Pass entity.
func (m *EventMutation) RemovedPassesIDs() (ids []uuid.UUID) {
	for id := range m.removedpasses {
		ids = append(ids, id)
	}
	return
}

// PassesIDs returns the "passes" edge IDs in the mutation.
func (m *EventMutation) PassesIDs() (ids []uuid.UUID) {
	for id := range m.passes {
		ids = append(ids, id)
	}
	return
}

// ResetPasses resets all changes to the "passes" edge.
func (m *EventMutation) ResetPasses() {
	m.passes = nil
	m.clearedpasses = false
	m.removedpasses = nil
}

// AddEventParticipantIDs adds the "event_participants" edge to the EventParticipant entity by ids.
func (m *EventMutation) AddEventParticipantIDs(ids ...uuid.UUID) {
	if m.event_participants == nil {
		m.event_participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.event_participants[ids[i]] = struct{}{}
	}
}

// ClearEventParticipants clears the "event_participants" edge to the EventParticipant entity.
func (m *EventMutation) ClearEventParticipants() {
	m.clearedevent_participants = true
}

// EventParticipantsCleared reports if the "event_participants" edge to the EventParticipant entity was cleared.
func (m *EventMutation) EventParticipantsCleared() bool {
	return m.clearedevent_participants
}

// RemoveEventParticipantIDs removes the "event_participants" edge to the EventParticipant entity by IDs.
func (m *EventMutation) RemoveEventParticipantIDs(ids ...uuid.UUID) {
	if m.removedevent_participants == nil {
		m.removedevent_participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.event_participants, ids[i])
		m.removedevent_participants[ids[i]] = struct{}{}
	}
}

// RemovedEventParticipants returns the removed IDs of the "event_participants" edge to the EventParticipant entity.
func (m *EventMutation) RemovedEventParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedevent_participants {
		ids = append(ids, id)
	}
	return
}

// EventParticipantsIDs returns the "event_participants" edge IDs in the mutation.
func (m *EventMutation) EventParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.event_participants {
		ids = append(ids, id)
	}
	return
}

// ResetEventParticipants resets all changes to the "event_participants" edge.
func (m *EventMutation) ResetEventParticipants() {
	m.event_participants = nil
	m.clearedevent_participants = false
	m.removedevent_participants = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.club != nil {
		fields = append(fields, event.FieldClubID)
	}
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.after_registration_text != nil {
		fields = append(fields, event.FieldAfterRegistrationText)
	}
	if m.location != nil {
		fields = append(fields, event.FieldLocation)
	}
	if m.start_time != nil {
		fields = append(fields, event.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, event.FieldEndTime)
	}
	if m.registration_end_time != nil {
		fields = append(fields, event.FieldRegistrationEndTime)
	}
	if m.max_participants != nil {
		fields = append(fields, event.FieldMaxParticipants)
	}
	if m.expected_participants != nil {
		fields = append(fields, event.FieldExpectedParticipants)
	}
	if m.qr_payload != nil {
		fields = append(fields, event.FieldQrPayload)
	}
	if m.qr_file_id != nil {
		fields = append(fields, event.FieldQrFileID)
	}
	if m.allowed_roles != nil {
		fields = append(fields, event.FieldAllowedRoles)
	}
	if m.pass_required != nil {
		fields = append(fields, event.FieldPassRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldClubID:
		return m.ClubID()
	case event.FieldName:
		return m.Name()
	case event.FieldDescription:
		return m.Description()
	case event.FieldAfterRegistrationText:
		return m.AfterRegistrationText()
	case event.FieldLocation:
		return m.Location()
	case event.FieldStartTime:
		return m.StartTime()
	case event.FieldEndTime:
		return m.EndTime()
	case event.FieldRegistrationEndTime:
		return m.RegistrationEndTime()
	case event.FieldMaxParticipants:
		return m.MaxParticipants()
	case event.FieldExpectedParticipants:
		return m.ExpectedParticipants()
	case event.FieldQrPayload:
		return m.QrPayload()
	case event.FieldQrFileID:
		return m.QrFileID()
	case event.FieldAllowedRoles:
		return m.AllowedRoles()
	case event.FieldPassRequired:
		return m.PassRequired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldClubID:
		return m.OldClubID(ctx)
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldAfterRegistrationText:
		return m.OldAfterRegistrationText(ctx)
	case event.FieldLocation:
		return m.OldLocation(ctx)
	case event.FieldStartTime:
		return m.OldStartTime(ctx)
	case event.FieldEndTime:
		return m.OldEndTime(ctx)
	case event.FieldRegistrationEndTime:
		return m.OldRegistrationEndTime(ctx)
	case event.FieldMaxParticipants:
		return m.OldMaxParticipants(ctx)
	case event.FieldExpectedParticipants:
		return m.OldExpectedParticipants(ctx)
	case event.FieldQrPayload:
		return m.OldQrPayload(ctx)
	case event.FieldQrFileID:
		return m.OldQrFileID(ctx)
	case event.FieldAllowedRoles:
		return m.OldAllowedRoles(ctx)
	case event.FieldPassRequired:
		return m.OldPassRequired(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldClubID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldAfterRegistrationText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterRegistrationText(v)
		return nil
	case event.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case event.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case event.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case event.FieldRegistrationEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationEndTime(v)
		return nil
	case event.FieldMaxParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxParticipants(v)
		return nil
	case event.FieldExpectedParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedParticipants(v)
		return nil
	case event.FieldQrPayload:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrPayload(v)
		return nil
	case event.FieldQrFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrFileID(v)
		return nil
	case event.FieldAllowedRoles:
		v, ok := value.(valueobject.Roles)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRoles(v)
		return nil
	case event.FieldPassRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassRequired(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addmax_participants != nil {
		fields = append(fields, event.FieldMaxParticipants)
	}
	if m.addexpected_participants != nil {
		fields = append(fields, event.FieldExpectedParticipants)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldMaxParticipants:
		return m.AddedMaxParticipants()
	case event.FieldExpectedParticipants:
		return m.AddedExpectedParticipants()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldMaxParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxParticipants(v)
		return nil
	case event.FieldExpectedParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpectedParticipants(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldAfterRegistrationText) {
		fields = append(fields, event.FieldAfterRegistrationText)
	}
	if m.FieldCleared(event.FieldEndTime) {
		fields = append(fields, event.FieldEndTime)
	}
	if m.FieldCleared(event.FieldMaxParticipants) {
		fields = append(fields, event.FieldMaxParticipants)
	}
	if m.FieldCleared(event.FieldExpectedParticipants) {
		fields = append(fields, event.FieldExpectedParticipants)
	}
	if m.FieldCleared(event.FieldQrPayload) {
		fields = append(fields, event.FieldQrPayload)
	}
	if m.FieldCleared(event.FieldQrFileID) {
		fields = append(fields, event.FieldQrFileID)
	}
	if m.FieldCleared(event.FieldAllowedRoles) {
		fields = append(fields, event.FieldAllowedRoles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldAfterRegistrationText:
		m.ClearAfterRegistrationText()
		return nil
	case event.FieldEndTime:
		m.ClearEndTime()
		return nil
	case event.FieldMaxParticipants:
		m.ClearMaxParticipants()
		return nil
	case event.FieldExpectedParticipants:
		m.ClearExpectedParticipants()
		return nil
	case event.FieldQrPayload:
		m.ClearQrPayload()
		return nil
	case event.FieldQrFileID:
		m.ClearQrFileID()
		return nil
	case event.FieldAllowedRoles:
		m.ClearAllowedRoles()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldClubID:
		m.ResetClubID()
		return nil
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldAfterRegistrationText:
		m.ResetAfterRegistrationText()
		return nil
	case event.FieldLocation:
		m.ResetLocation()
		return nil
	case event.FieldStartTime:
		m.ResetStartTime()
		return nil
	case event.FieldEndTime:
		m.ResetEndTime()
		return nil
	case event.FieldRegistrationEndTime:
		m.ResetRegistrationEndTime()
		return nil
	case event.FieldMaxParticipants:
		m.ResetMaxParticipants()
		return nil
	case event.FieldExpectedParticipants:
		m.ResetExpectedParticipants()
		return nil
	case event.FieldQrPayload:
		m.ResetQrPayload()
		return nil
	case event.FieldQrFileID:
		m.ResetQrFileID()
		return nil
	case event.FieldAllowedRoles:
		m.ResetAllowedRoles()
		return nil
	case event.FieldPassRequired:
		m.ResetPassRequired()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.club != nil {
		edges = append(edges, event.EdgeClub)
	}
	if m.participants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.notifications != nil {
		edges = append(edges, event.EdgeNotifications)
	}
	if m.passes != nil {
		edges = append(edges, event.EdgePasses)
	}
	if m.event_participants != nil {
		edges = append(edges, event.EdgeEventParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePasses:
		ids := make([]ent.Value, 0, len(m.passes))
		for id := range m.passes {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventParticipants:
		ids := make([]ent.Value, 0, len(m.event_participants))
		for id := range m.event_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedparticipants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.removednotifications != nil {
		edges = append(edges, event.EdgeNotifications)
	}
	if m.removedpasses != nil {
		edges = append(edges, event.EdgePasses)
	}
	if m.removedevent_participants != nil {
		edges = append(edges, event.EdgeEventParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePasses:
		ids := make([]ent.Value, 0, len(m.removedpasses))
		for id := range m.removedpasses {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEventParticipants:
		ids := make([]ent.Value, 0, len(m.removedevent_participants))
		for id := range m.removedevent_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedclub {
		edges = append(edges, event.EdgeClub)
	}
	if m.clearedparticipants {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.clearednotifications {
		edges = append(edges, event.EdgeNotifications)
	}
	if m.clearedpasses {
		edges = append(edges, event.EdgePasses)
	}
	if m.clearedevent_participants {
		edges = append(edges, event.EdgeEventParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeClub:
		return m.clearedclub
	case event.EdgeParticipants:
		return m.clearedparticipants
	case event.EdgeNotifications:
		return m.clearednotifications
	case event.EdgePasses:
		return m.clearedpasses
	case event.EdgeEventParticipants:
		return m.clearedevent_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeClub:
		m.ResetClub()
		return nil
	case event.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case event.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case event.EdgePasses:
		m.ResetPasses()
		return nil
	case event.EdgeEventParticipants:
		m.ResetEventParticipants()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventParticipantMutation represents an operation that mutates the EventParticipant nodes in the graph.
type EventParticipantMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	deleted_at        *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	attendance_method *eventparticipant.AttendanceMethod
	attended_at       *time.Time
	clearedFields     map[string]struct{}
	event             *uuid.UUID
	clearedevent      bool
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*EventParticipant, error)
	predicates        []predicate.EventParticipant
}

var _ ent.Mutation = (*EventParticipantMutation)(nil)

// eventparticipantOption allows management of the mutation configuration using functional options.
type eventparticipantOption func(*EventParticipantMutation)

// newEventParticipantMutation creates new mutation for the EventParticipant entity.
func newEventParticipantMutation(c config, op Op, opts ...eventparticipantOption) *EventParticipantMutation {
	m := &EventParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeEventParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventParticipantID sets the ID field of the mutation.
func withEventParticipantID(id uuid.UUID) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *EventParticipant
		)
		m.oldValue = func(ctx context.Context) (*EventParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventParticipant sets the old EventParticipant of the mutation.
func withEventParticipant(node *EventParticipant) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		m.oldValue = func(context.Context) (*EventParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventParticipant entities.
func (m *EventParticipantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventParticipantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventParticipantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventParticipantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventParticipantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventParticipantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[eventparticipant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventParticipantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[eventparticipant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventParticipantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, eventparticipant.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *EventParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *EventParticipantMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventParticipantMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventParticipantMutation) ResetEventID() {
	m.event = nil
}

// SetUserID sets the "user_id" field.
func (m *EventParticipantMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EventParticipantMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EventParticipantMutation) ResetUserID() {
	m.user = nil
}

// SetAttendanceMethod sets the "attendance_method" field.
func (m *EventParticipantMutation) SetAttendanceMethod(em eventparticipant.AttendanceMethod) {
	m.attendance_method = &em
}

// AttendanceMethod returns the value of the "attendance_method" field in the mutation.
func (m *EventParticipantMutation) AttendanceMethod() (r eventparticipant.AttendanceMethod, exists bool) {
	v := m.attendance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldAttendanceMethod returns the old "attendance_method" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldAttendanceMethod(ctx context.Context) (v eventparticipant.AttendanceMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttendanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttendanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttendanceMethod: %w", err)
	}
	return oldValue.AttendanceMethod, nil
}

// ResetAttendanceMethod resets all changes to the "attendance_method" field.
func (m *EventParticipantMutation) ResetAttendanceMethod() {
	m.attendance_method = nil
}

// SetAttendedAt sets the "attended_at" field.
func (m *EventParticipantMutation) SetAttendedAt(t time.Time) {
	m.attended_at = &t
}

// AttendedAt returns the value of the "attended_at" field in the mutation.
func (m *EventParticipantMutation) AttendedAt() (r time.Time, exists bool) {
	v := m.attended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAttendedAt returns the old "attended_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldAttendedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttendedAt: %w", err)
	}
	return oldValue.AttendedAt, nil
}

// ClearAttendedAt clears the value of the "attended_at" field.
func (m *EventParticipantMutation) ClearAttendedAt() {
	m.attended_at = nil
	m.clearedFields[eventparticipant.FieldAttendedAt] = struct{}{}
}

// AttendedAtCleared returns if the "attended_at" field was cleared in this mutation.
func (m *EventParticipantMutation) AttendedAtCleared() bool {
	_, ok := m.clearedFields[eventparticipant.FieldAttendedAt]
	return ok
}

// ResetAttendedAt resets all changes to the "attended_at" field.
func (m *EventParticipantMutation) ResetAttendedAt() {
	m.attended_at = nil
	delete(m.clearedFields, eventparticipant.FieldAttendedAt)
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventParticipantMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[eventparticipant.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventParticipantMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventParticipantMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *EventParticipantMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[eventparticipant.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EventParticipantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EventParticipantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EventParticipantMutation builder.
func (m *EventParticipantMutation) Where(ps ...predicate.EventParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventParticipant).
func (m *EventParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventParticipantMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, eventparticipant.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, eventparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventparticipant.FieldUpdatedAt)
	}
	if m.event != nil {
		fields = append(fields, eventparticipant.FieldEventID)
	}
	if m.user != nil {
		fields = append(fields, eventparticipant.FieldUserID)
	}
	if m.attendance_method != nil {
		fields = append(fields, eventparticipant.FieldAttendanceMethod)
	}
	if m.attended_at != nil {
		fields = append(fields, eventparticipant.FieldAttendedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventparticipant.FieldDeletedAt:
		return m.DeletedAt()
	case eventparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case eventparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventparticipant.FieldEventID:
		return m.EventID()
	case eventparticipant.FieldUserID:
		return m.UserID()
	case eventparticipant.FieldAttendanceMethod:
		return m.AttendanceMethod()
	case eventparticipant.FieldAttendedAt:
		return m.AttendedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventparticipant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case eventparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventparticipant.FieldEventID:
		return m.OldEventID(ctx)
	case eventparticipant.FieldUserID:
		return m.OldUserID(ctx)
	case eventparticipant.FieldAttendanceMethod:
		return m.OldAttendanceMethod(ctx)
	case eventparticipant.FieldAttendedAt:
		return m.OldAttendedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EventParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventparticipant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case eventparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventparticipant.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventparticipant.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case eventparticipant.FieldAttendanceMethod:
		v, ok := value.(eventparticipant.AttendanceMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttendanceMethod(v)
		return nil
	case eventparticipant.FieldAttendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttendedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventparticipant.FieldDeletedAt) {
		fields = append(fields, eventparticipant.FieldDeletedAt)
	}
	if m.FieldCleared(eventparticipant.FieldAttendedAt) {
		fields = append(fields, eventparticipant.FieldAttendedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventParticipantMutation) ClearField(name string) error {
	switch name {
	case eventparticipant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case eventparticipant.FieldAttendedAt:
		m.ClearAttendedAt()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventParticipantMutation) ResetField(name string) error {
	switch name {
	case eventparticipant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case eventparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventparticipant.FieldEventID:
		m.ResetEventID()
		return nil
	case eventparticipant.FieldUserID:
		m.ResetUserID()
		return nil
	case eventparticipant.FieldAttendanceMethod:
		m.ResetAttendanceMethod()
		return nil
	case eventparticipant.FieldAttendedAt:
		m.ResetAttendedAt()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	if m.user != nil {
		edges = append(edges, eventparticipant.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventparticipant.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case eventparticipant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	if m.cleareduser {
		edges = append(edges, eventparticipant.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case eventparticipant.EdgeEvent:
		return m.clearedevent
	case eventparticipant.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventParticipantMutation) ClearEdge(name string) error {
	switch name {
	case eventparticipant.EdgeEvent:
		m.ClearEvent()
		return nil
	case eventparticipant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventParticipantMutation) ResetEdge(name string) error {
	switch name {
	case eventparticipant.EdgeEvent:
		m.ResetEvent()
		return nil
	case eventparticipant.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant edge %s", name)
}

// IgnoreMailingMutation represents an operation that mutates the IgnoreMailing nodes in the graph.
type IgnoreMailingMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	club          *uuid.UUID
	clearedclub   bool
	done          bool
	oldValue      func(context.Context) (*IgnoreMailing, error)
	predicates    []predicate.IgnoreMailing
}

var _ ent.Mutation = (*IgnoreMailingMutation)(nil)

// ignoremailingOption allows management of the mutation configuration using functional options.
type ignoremailingOption func(*IgnoreMailingMutation)

// newIgnoreMailingMutation creates new mutation for the IgnoreMailing entity.
func newIgnoreMailingMutation(c config, op Op, opts ...ignoremailingOption) *IgnoreMailingMutation {
	m := &IgnoreMailingMutation{
		config:        c,
		op:            op,
		typ:           TypeIgnoreMailing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIgnoreMailingID sets the ID field of the mutation.
func withIgnoreMailingID(id uuid.UUID) ignoremailingOption {
	return func(m *IgnoreMailingMutation) {
		var (
			err   error
			once  sync.Once
			value *IgnoreMailing
		)
		m.oldValue = func(ctx context.Context) (*IgnoreMailing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IgnoreMailing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIgnoreMailing sets the old IgnoreMailing of the mutation.
func withIgnoreMailing(node *IgnoreMailing) ignoremailingOption {
	return func(m *IgnoreMailingMutation) {
		m.oldValue = func(context.Context) (*IgnoreMailing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IgnoreMailingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IgnoreMailingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IgnoreMailing entities.
func (m *IgnoreMailingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IgnoreMailingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IgnoreMailingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IgnoreMailing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IgnoreMailingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IgnoreMailingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IgnoreMailing entity.
// If the IgnoreMailing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoreMailingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IgnoreMailingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ignoremailing.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IgnoreMailingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ignoremailing.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IgnoreMailingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ignoremailing.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *IgnoreMailingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IgnoreMailingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IgnoreMailing entity.
// If the IgnoreMailing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoreMailingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IgnoreMailingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IgnoreMailingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IgnoreMailingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IgnoreMailing entity.
// If the IgnoreMailing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoreMailingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IgnoreMailingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *IgnoreMailingMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IgnoreMailingMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IgnoreMailing entity.
// If the IgnoreMailing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoreMailingMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IgnoreMailingMutation) ResetUserID() {
	m.user = nil
}

// SetClubID sets the "club_id" field.
func (m *IgnoreMailingMutation) SetClubID(u uuid.UUID) {
	m.club = &u
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *IgnoreMailingMutation) ClubID() (r uuid.UUID, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the IgnoreMailing entity.
// If the IgnoreMailing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IgnoreMailingMutation) OldClubID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *IgnoreMailingMutation) ResetClubID() {
	m.club = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *IgnoreMailingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[ignoremailing.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IgnoreMailingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IgnoreMailingMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IgnoreMailingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearClub clears the "club" edge to the Club entity.
func (m *IgnoreMailingMutation) ClearClub() {
	m.clearedclub = true
	m.clearedFields[ignoremailing.FieldClubID] = struct{}{}
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *IgnoreMailingMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *IgnoreMailingMutation) ClubIDs() (ids []uuid.UUID) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *IgnoreMailingMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// Where appends a list predicates to the IgnoreMailingMutation builder.
func (m *IgnoreMailingMutation) Where(ps ...predicate.IgnoreMailing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IgnoreMailingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IgnoreMailingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IgnoreMailing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IgnoreMailingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IgnoreMailingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IgnoreMailing).
func (m *IgnoreMailingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IgnoreMailingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, ignoremailing.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, ignoremailing.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ignoremailing.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, ignoremailing.FieldUserID)
	}
	if m.club != nil {
		fields = append(fields, ignoremailing.FieldClubID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IgnoreMailingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ignoremailing.FieldDeletedAt:
		return m.DeletedAt()
	case ignoremailing.FieldCreatedAt:
		return m.CreatedAt()
	case ignoremailing.FieldUpdatedAt:
		return m.UpdatedAt()
	case ignoremailing.FieldUserID:
		return m.UserID()
	case ignoremailing.FieldClubID:
		return m.ClubID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IgnoreMailingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ignoremailing.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ignoremailing.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ignoremailing.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ignoremailing.FieldUserID:
		return m.OldUserID(ctx)
	case ignoremailing.FieldClubID:
		return m.OldClubID(ctx)
	}
	return nil, fmt.Errorf("unknown IgnoreMailing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IgnoreMailingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ignoremailing.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ignoremailing.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ignoremailing.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ignoremailing.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ignoremailing.FieldClubID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	}
	return fmt.Errorf("unknown IgnoreMailing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IgnoreMailingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IgnoreMailingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IgnoreMailingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IgnoreMailing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IgnoreMailingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ignoremailing.FieldDeletedAt) {
		fields = append(fields, ignoremailing.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IgnoreMailingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IgnoreMailingMutation) ClearField(name string) error {
	switch name {
	case ignoremailing.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown IgnoreMailing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IgnoreMailingMutation) ResetField(name string) error {
	switch name {
	case ignoremailing.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ignoremailing.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ignoremailing.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ignoremailing.FieldUserID:
		m.ResetUserID()
		return nil
	case ignoremailing.FieldClubID:
		m.ResetClubID()
		return nil
	}
	return fmt.Errorf("unknown IgnoreMailing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IgnoreMailingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, ignoremailing.EdgeUser)
	}
	if m.club != nil {
		edges = append(edges, ignoremailing.EdgeClub)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IgnoreMailingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ignoremailing.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case ignoremailing.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IgnoreMailingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IgnoreMailingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IgnoreMailingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, ignoremailing.EdgeUser)
	}
	if m.clearedclub {
		edges = append(edges, ignoremailing.EdgeClub)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IgnoreMailingMutation) EdgeCleared(name string) bool {
	switch name {
	case ignoremailing.EdgeUser:
		return m.cleareduser
	case ignoremailing.EdgeClub:
		return m.clearedclub
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IgnoreMailingMutation) ClearEdge(name string) error {
	switch name {
	case ignoremailing.EdgeUser:
		m.ClearUser()
		return nil
	case ignoremailing.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown IgnoreMailing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IgnoreMailingMutation) ResetEdge(name string) error {
	switch name {
	case ignoremailing.EdgeUser:
		m.ResetUser()
		return nil
	case ignoremailing.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown IgnoreMailing edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	_type         *notification.Type
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id uuid.UUID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notification.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notification.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *NotificationMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *NotificationMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *NotificationMutation) ResetEventID() {
	m.event = nil
}

// SetUserID sets the "user_id" field.
func (m *NotificationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(n notification.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r notification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v notification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *NotificationMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[notification.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *NotificationMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *NotificationMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotificationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[notification.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m.event != nil {
		fields = append(fields, notification.FieldEventID)
	}
	if m.user != nil {
		fields = append(fields, notification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldDeletedAt:
		return m.DeletedAt()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldEventID:
		return m.EventID()
	case notification.FieldUserID:
		return m.UserID()
	case notification.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldEventID:
		return m.OldEventID(ctx)
	case notification.FieldUserID:
		return m.OldUserID(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case notification.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notification.FieldType:
		v, ok := value.(notification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldDeletedAt) {
		fields = append(fields, notification.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldEventID:
		m.ResetEventID()
		return nil
	case notification.FieldUserID:
		m.ResetUserID()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, notification.EdgeEvent)
	}
	if m.user != nil {
		edges = append(edges, notification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, notification.EdgeEvent)
	}
	if m.cleareduser {
		edges = append(edges, notification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeEvent:
		return m.clearedevent
	case notification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeEvent:
		m.ClearEvent()
		return nil
	case notification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeEvent:
		m.ResetEvent()
		return nil
	case notification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PassMutation represents an operation that mutates the Pass nodes in the graph.
type PassMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	_type          *valueobject.PassType
	status         *valueobject.PassStatus
	requester_type *valueobject.RequesterType
	requester_id   *uuid.UUID
	scheduled_at   *time.Time
	sent_at        *time.Time
	notes          *string
	email_sent     *bool
	telegram_sent  *bool
	clearedFields  map[string]struct{}
	event          *uuid.UUID
	clearedevent   bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Pass, error)
	predicates     []predicate.Pass
}

var _ ent.Mutation = (*PassMutation)(nil)

// passOption allows management of the mutation configuration using functional options.
type passOption func(*PassMutation)

// newPassMutation creates new mutation for the Pass entity.
func newPassMutation(c config, op Op, opts ...passOption) *PassMutation {
	m := &PassMutation{
		config:        c,
		op:            op,
		typ:           TypePass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPassID sets the ID field of the mutation.
func withPassID(id uuid.UUID) passOption {
	return func(m *PassMutation) {
		var (
			err   error
			once  sync.Once
			value *Pass
		)
		m.oldValue = func(ctx context.Context) (*Pass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPass sets the old Pass of the mutation.
func withPass(node *Pass) passOption {
	return func(m *PassMutation) {
		m.oldValue = func(context.Context) (*Pass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pass entities.
func (m *PassMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PassMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PassMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *PassMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *PassMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *PassMutation) ResetEventID() {
	m.event = nil
}

// SetUserID sets the "user_id" field.
func (m *PassMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PassMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PassMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *PassMutation) SetType(vt valueobject.PassType) {
	m._type = &vt
}

// GetType returns the value of the "type" field in the mutation.
func (m *PassMutation) GetType() (r valueobject.PassType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldType(ctx context.Context) (v valueobject.PassType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PassMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *PassMutation) SetStatus(vs valueobject.PassStatus) {
	m.status = &vs
}

// Status returns the value of the "status" field in the mutation.
func (m *PassMutation) Status() (r valueobject.PassStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldStatus(ctx context.Context) (v valueobject.PassStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PassMutation) ResetStatus() {
	m.status = nil
}

// SetRequesterType sets the "requester_type" field.
func (m *PassMutation) SetRequesterType(vt valueobject.RequesterType) {
	m.requester_type = &vt
}

// RequesterType returns the value of the "requester_type" field in the mutation.
func (m *PassMutation) RequesterType() (r valueobject.RequesterType, exists bool) {
	v := m.requester_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterType returns the old "requester_type" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldRequesterType(ctx context.Context) (v valueobject.RequesterType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterType: %w", err)
	}
	return oldValue.RequesterType, nil
}

// ResetRequesterType resets all changes to the "requester_type" field.
func (m *PassMutation) ResetRequesterType() {
	m.requester_type = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *PassMutation) SetRequesterID(u uuid.UUID) {
	m.requester_id = &u
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *PassMutation) RequesterID() (r uuid.UUID, exists bool) {
	v := m.requester_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldRequesterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// ClearRequesterID clears the value of the "requester_id" field.
func (m *PassMutation) ClearRequesterID() {
	m.requester_id = nil
	m.clearedFields[pass.FieldRequesterID] = struct{}{}
}

// RequesterIDCleared returns if the "requester_id" field was cleared in this mutation.
func (m *PassMutation) RequesterIDCleared() bool {
	_, ok := m.clearedFields[pass.FieldRequesterID]
	return ok
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *PassMutation) ResetRequesterID() {
	m.requester_id = nil
	delete(m.clearedFields, pass.FieldRequesterID)
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *PassMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *PassMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *PassMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetSentAt sets the "sent_at" field.
func (m *PassMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *PassMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *PassMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[pass.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *PassMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[pass.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *PassMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, pass.FieldSentAt)
}

// SetNotes sets the "notes" field.
func (m *PassMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PassMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PassMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[pass.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PassMutation) NotesCleared() bool {
	_, ok := m.clearedFields[pass.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PassMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, pass.FieldNotes)
}

// SetEmailSent sets the "email_sent" field.
func (m *PassMutation) SetEmailSent(b bool) {
	m.email_sent = &b
}

// EmailSent returns the value of the "email_sent" field in the mutation.
func (m *PassMutation) EmailSent() (r bool, exists bool) {
	v := m.email_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailSent returns the old "email_sent" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldEmailSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailSent: %w", err)
	}
	return oldValue.EmailSent, nil
}

// ResetEmailSent resets all changes to the "email_sent" field.
func (m *PassMutation) ResetEmailSent() {
	m.email_sent = nil
}

// SetTelegramSent sets the "telegram_sent" field.
func (m *PassMutation) SetTelegramSent(b bool) {
	m.telegram_sent = &b
}

// TelegramSent returns the value of the "telegram_sent" field in the mutation.
func (m *PassMutation) TelegramSent() (r bool, exists bool) {
	v := m.telegram_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegramSent returns the old "telegram_sent" field's value of the Pass entity.
// If the Pass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassMutation) OldTelegramSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelegramSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelegramSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegramSent: %w", err)
	}
	return oldValue.TelegramSent, nil
}

// ResetTelegramSent resets all changes to the "telegram_sent" field.
func (m *PassMutation) ResetTelegramSent() {
	m.telegram_sent = nil
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *PassMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[pass.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *PassMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *PassMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *PassMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PassMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[pass.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PassMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PassMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PassMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PassMutation builder.
func (m *PassMutation) Where(ps ...predicate.Pass) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pass, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pass).
func (m *PassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PassMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, pass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pass.FieldUpdatedAt)
	}
	if m.event != nil {
		fields = append(fields, pass.FieldEventID)
	}
	if m.user != nil {
		fields = append(fields, pass.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, pass.FieldType)
	}
	if m.status != nil {
		fields = append(fields, pass.FieldStatus)
	}
	if m.requester_type != nil {
		fields = append(fields, pass.FieldRequesterType)
	}
	if m.requester_id != nil {
		fields = append(fields, pass.FieldRequesterID)
	}
	if m.scheduled_at != nil {
		fields = append(fields, pass.FieldScheduledAt)
	}
	if m.sent_at != nil {
		fields = append(fields, pass.FieldSentAt)
	}
	if m.notes != nil {
		fields = append(fields, pass.FieldNotes)
	}
	if m.email_sent != nil {
		fields = append(fields, pass.FieldEmailSent)
	}
	if m.telegram_sent != nil {
		fields = append(fields, pass.FieldTelegramSent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pass.FieldCreatedAt:
		return m.CreatedAt()
	case pass.FieldUpdatedAt:
		return m.UpdatedAt()
	case pass.FieldEventID:
		return m.EventID()
	case pass.FieldUserID:
		return m.UserID()
	case pass.FieldType:
		return m.GetType()
	case pass.FieldStatus:
		return m.Status()
	case pass.FieldRequesterType:
		return m.RequesterType()
	case pass.FieldRequesterID:
		return m.RequesterID()
	case pass.FieldScheduledAt:
		return m.ScheduledAt()
	case pass.FieldSentAt:
		return m.SentAt()
	case pass.FieldNotes:
		return m.Notes()
	case pass.FieldEmailSent:
		return m.EmailSent()
	case pass.FieldTelegramSent:
		return m.TelegramSent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pass.FieldEventID:
		return m.OldEventID(ctx)
	case pass.FieldUserID:
		return m.OldUserID(ctx)
	case pass.FieldType:
		return m.OldType(ctx)
	case pass.FieldStatus:
		return m.OldStatus(ctx)
	case pass.FieldRequesterType:
		return m.OldRequesterType(ctx)
	case pass.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case pass.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case pass.FieldSentAt:
		return m.OldSentAt(ctx)
	case pass.FieldNotes:
		return m.OldNotes(ctx)
	case pass.FieldEmailSent:
		return m.OldEmailSent(ctx)
	case pass.FieldTelegramSent:
		return m.OldTelegramSent(ctx)
	}
	return nil, fmt.Errorf("unknown Pass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pass.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case pass.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case pass.FieldType:
		v, ok := value.(valueobject.PassType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pass.FieldStatus:
		v, ok := value.(valueobject.PassStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pass.FieldRequesterType:
		v, ok := value.(valueobject.RequesterType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterType(v)
		return nil
	case pass.FieldRequesterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case pass.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case pass.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case pass.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case pass.FieldEmailSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailSent(v)
		return nil
	case pass.FieldTelegramSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegramSent(v)
		return nil
	}
	return fmt.Errorf("unknown Pass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pass.FieldRequesterID) {
		fields = append(fields, pass.FieldRequesterID)
	}
	if m.FieldCleared(pass.FieldSentAt) {
		fields = append(fields, pass.FieldSentAt)
	}
	if m.FieldCleared(pass.FieldNotes) {
		fields = append(fields, pass.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PassMutation) ClearField(name string) error {
	switch name {
	case pass.FieldRequesterID:
		m.ClearRequesterID()
		return nil
	case pass.FieldSentAt:
		m.ClearSentAt()
		return nil
	case pass.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Pass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PassMutation) ResetField(name string) error {
	switch name {
	case pass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pass.FieldEventID:
		m.ResetEventID()
		return nil
	case pass.FieldUserID:
		m.ResetUserID()
		return nil
	case pass.FieldType:
		m.ResetType()
		return nil
	case pass.FieldStatus:
		m.ResetStatus()
		return nil
	case pass.FieldRequesterType:
		m.ResetRequesterType()
		return nil
	case pass.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case pass.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case pass.FieldSentAt:
		m.ResetSentAt()
		return nil
	case pass.FieldNotes:
		m.ResetNotes()
		return nil
	case pass.FieldEmailSent:
		m.ResetEmailSent()
		return nil
	case pass.FieldTelegramSent:
		m.ResetTelegramSent()
		return nil
	}
	return fmt.Errorf("unknown Pass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, pass.EdgeEvent)
	}
	if m.user != nil {
		edges = append(edges, pass.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pass.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case pass.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PassMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, pass.EdgeEvent)
	}
	if m.cleareduser {
		edges = append(edges, pass.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PassMutation) EdgeCleared(name string) bool {
	switch name {
	case pass.EdgeEvent:
		return m.clearedevent
	case pass.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PassMutation) ClearEdge(name string) error {
	switch name {
	case pass.EdgeEvent:
		m.ClearEvent()
		return nil
	case pass.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Pass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PassMutation) ResetEdge(name string) error {
	switch name {
	case pass.EdgeEvent:
		m.ResetEvent()
		return nil
	case pass.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Pass edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	telegram_id               *int64
	addtelegram_id            *int64
	localization              *user.Localization
	username                  *string
	role                      *valueobject.Role
	email                     *valueobject.Email
	fio                       *valueobject.FIO
	qr_payload                *uuid.UUID
	qr_file_id                *string
	is_banned                 *bool
	clearedFields             map[string]struct{}
	owned_clubs               map[uuid.UUID]struct{}
	removedowned_clubs        map[uuid.UUID]struct{}
	clearedowned_clubs        bool
	events                    map[uuid.UUID]struct{}
	removedevents             map[uuid.UUID]struct{}
	clearedevents             bool
	ignore_mailings           map[uuid.UUID]struct{}
	removedignore_mailings    map[uuid.UUID]struct{}
	clearedignore_mailings    bool
	notifications             map[uuid.UUID]struct{}
	removednotifications      map[uuid.UUID]struct{}
	clearednotifications      bool
	passes                    map[uuid.UUID]struct{}
	removedpasses             map[uuid.UUID]struct{}
	clearedpasses             bool
	club_owners               map[uuid.UUID]struct{}
	removedclub_owners        map[uuid.UUID]struct{}
	clearedclub_owners        bool
	event_participants        map[uuid.UUID]struct{}
	removedevent_participants map[uuid.UUID]struct{}
	clearedevent_participants bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTelegramID sets the "telegram_id" field.
func (m *UserMutation) SetTelegramID(i int64) {
	m.telegram_id = &i
	m.addtelegram_id = nil
}

// TelegramID returns the value of the "telegram_id" field in the mutation.
func (m *UserMutation) TelegramID() (r int64, exists bool) {
	v := m.telegram_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegramID returns the old "telegram_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelegramID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelegramID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelegramID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegramID: %w", err)
	}
	return oldValue.TelegramID, nil
}

// AddTelegramID adds i to the "telegram_id" field.
func (m *UserMutation) AddTelegramID(i int64) {
	if m.addtelegram_id != nil {
		*m.addtelegram_id += i
	} else {
		m.addtelegram_id = &i
	}
}

// AddedTelegramID returns the value that was added to the "telegram_id" field in this mutation.
func (m *UserMutation) AddedTelegramID() (r int64, exists bool) {
	v := m.addtelegram_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTelegramID resets all changes to the "telegram_id" field.
func (m *UserMutation) ResetTelegramID() {
	m.telegram_id = nil
	m.addtelegram_id = nil
}

// SetLocalization sets the "localization" field.
func (m *UserMutation) SetLocalization(u user.Localization) {
	m.localization = &u
}

// Localization returns the value of the "localization" field in the mutation.
func (m *UserMutation) Localization() (r user.Localization, exists bool) {
	v := m.localization
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalization returns the old "localization" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocalization(ctx context.Context) (v user.Localization, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalization: %w", err)
	}
	return oldValue.Localization, nil
}

// ResetLocalization resets all changes to the "localization" field.
func (m *UserMutation) ResetLocalization() {
	m.localization = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(v valueobject.Role) {
	m.role = &v
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r valueobject.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v valueobject.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(v valueobject.Email) {
	m.email = &v
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r valueobject.Email, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v valueobject.Email, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetFio sets the "fio" field.
func (m *UserMutation) SetFio(v valueobject.FIO) {
	m.fio = &v
}

// Fio returns the value of the "fio" field in the mutation.
func (m *UserMutation) Fio() (r valueobject.FIO, exists bool) {
	v := m.fio
	if v == nil {
		return
	}
	return *v, true
}

// OldFio returns the old "fio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFio(ctx context.Context) (v valueobject.FIO, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFio: %w", err)
	}
	return oldValue.Fio, nil
}

// ResetFio resets all changes to the "fio" field.
func (m *UserMutation) ResetFio() {
	m.fio = nil
}

// SetQrPayload sets the "qr_payload" field.
func (m *UserMutation) SetQrPayload(u uuid.UUID) {
	m.qr_payload = &u
}

// QrPayload returns the value of the "qr_payload" field in the mutation.
func (m *UserMutation) QrPayload() (r uuid.UUID, exists bool) {
	v := m.qr_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldQrPayload returns the old "qr_payload" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldQrPayload(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrPayload: %w", err)
	}
	return oldValue.QrPayload, nil
}

// ClearQrPayload clears the value of the "qr_payload" field.
func (m *UserMutation) ClearQrPayload() {
	m.qr_payload = nil
	m.clearedFields[user.FieldQrPayload] = struct{}{}
}

// QrPayloadCleared returns if the "qr_payload" field was cleared in this mutation.
func (m *UserMutation) QrPayloadCleared() bool {
	_, ok := m.clearedFields[user.FieldQrPayload]
	return ok
}

// ResetQrPayload resets all changes to the "qr_payload" field.
func (m *UserMutation) ResetQrPayload() {
	m.qr_payload = nil
	delete(m.clearedFields, user.FieldQrPayload)
}

// SetQrFileID sets the "qr_file_id" field.
func (m *UserMutation) SetQrFileID(s string) {
	m.qr_file_id = &s
}

// QrFileID returns the value of the "qr_file_id" field in the mutation.
func (m *UserMutation) QrFileID() (r string, exists bool) {
	v := m.qr_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQrFileID returns the old "qr_file_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldQrFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrFileID: %w", err)
	}
	return oldValue.QrFileID, nil
}

// ClearQrFileID clears the value of the "qr_file_id" field.
func (m *UserMutation) ClearQrFileID() {
	m.qr_file_id = nil
	m.clearedFields[user.FieldQrFileID] = struct{}{}
}

// QrFileIDCleared returns if the "qr_file_id" field was cleared in this mutation.
func (m *UserMutation) QrFileIDCleared() bool {
	_, ok := m.clearedFields[user.FieldQrFileID]
	return ok
}

// ResetQrFileID resets all changes to the "qr_file_id" field.
func (m *UserMutation) ResetQrFileID() {
	m.qr_file_id = nil
	delete(m.clearedFields, user.FieldQrFileID)
}

// SetIsBanned sets the "is_banned" field.
func (m *UserMutation) SetIsBanned(b bool) {
	m.is_banned = &b
}

// IsBanned returns the value of the "is_banned" field in the mutation.
func (m *UserMutation) IsBanned() (r bool, exists bool) {
	v := m.is_banned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBanned returns the old "is_banned" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBanned: %w", err)
	}
	return oldValue.IsBanned, nil
}

// ResetIsBanned resets all changes to the "is_banned" field.
func (m *UserMutation) ResetIsBanned() {
	m.is_banned = nil
}

// AddOwnedClubIDs adds the "owned_clubs" edge to the Club entity by ids.
func (m *UserMutation) AddOwnedClubIDs(ids ...uuid.UUID) {
	if m.owned_clubs == nil {
		m.owned_clubs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.owned_clubs[ids[i]] = struct{}{}
	}
}

// ClearOwnedClubs clears the "owned_clubs" edge to the Club entity.
func (m *UserMutation) ClearOwnedClubs() {
	m.clearedowned_clubs = true
}

// OwnedClubsCleared reports if the "owned_clubs" edge to the Club entity was cleared.
func (m *UserMutation) OwnedClubsCleared() bool {
	return m.clearedowned_clubs
}

// RemoveOwnedClubIDs removes the "owned_clubs" edge to the Club entity by IDs.
func (m *UserMutation) RemoveOwnedClubIDs(ids ...uuid.UUID) {
	if m.removedowned_clubs == nil {
		m.removedowned_clubs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.owned_clubs, ids[i])
		m.removedowned_clubs[ids[i]] = struct{}{}
	}
}

// RemovedOwnedClubs returns the removed IDs of the "owned_clubs" edge to the Club entity.
func (m *UserMutation) RemovedOwnedClubsIDs() (ids []uuid.UUID) {
	for id := range m.removedowned_clubs {
		ids = append(ids, id)
	}
	return
}

// OwnedClubsIDs returns the "owned_clubs" edge IDs in the mutation.
func (m *UserMutation) OwnedClubsIDs() (ids []uuid.UUID) {
	for id := range m.owned_clubs {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedClubs resets all changes to the "owned_clubs" edge.
func (m *UserMutation) ResetOwnedClubs() {
	m.owned_clubs = nil
	m.clearedowned_clubs = false
	m.removedowned_clubs = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *UserMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *UserMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddIgnoreMailingIDs adds the "ignore_mailings" edge to the IgnoreMailing entity by ids.
func (m *UserMutation) AddIgnoreMailingIDs(ids ...uuid.UUID) {
	if m.ignore_mailings == nil {
		m.ignore_mailings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ignore_mailings[ids[i]] = struct{}{}
	}
}

// ClearIgnoreMailings clears the "ignore_mailings" edge to the IgnoreMailing entity.
func (m *UserMutation) ClearIgnoreMailings() {
	m.clearedignore_mailings = true
}

// IgnoreMailingsCleared reports if the "ignore_mailings" edge to the IgnoreMailing entity was cleared.
func (m *UserMutation) IgnoreMailingsCleared() bool {
	return m.clearedignore_mailings
}

// RemoveIgnoreMailingIDs removes the "ignore_mailings" edge to the IgnoreMailing entity by IDs.
func (m *UserMutation) RemoveIgnoreMailingIDs(ids ...uuid.UUID) {
	if m.removedignore_mailings == nil {
		m.removedignore_mailings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ignore_mailings, ids[i])
		m.removedignore_mailings[ids[i]] = struct{}{}
	}
}

// RemovedIgnoreMailings returns the removed IDs of the "ignore_mailings" edge to the IgnoreMailing entity.
func (m *UserMutation) RemovedIgnoreMailingsIDs() (ids []uuid.UUID) {
	for id := range m.removedignore_mailings {
		ids = append(ids, id)
	}
	return
}

// IgnoreMailingsIDs returns the "ignore_mailings" edge IDs in the mutation.
func (m *UserMutation) IgnoreMailingsIDs() (ids []uuid.UUID) {
	for id := range m.ignore_mailings {
		ids = append(ids, id)
	}
	return
}

// ResetIgnoreMailings resets all changes to the "ignore_mailings" edge.
func (m *UserMutation) ResetIgnoreMailings() {
	m.ignore_mailings = nil
	m.clearedignore_mailings = false
	m.removedignore_mailings = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *UserMutation) AddNotificationIDs(ids ...uuid.UUID) {
	if m.notifications == nil {
		m.notifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *UserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *UserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *UserMutation) RemoveNotificationIDs(ids ...uuid.UUID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *UserMutation) RemovedNotificationsIDs() (ids []uuid.UUID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *UserMutation) NotificationsIDs() (ids []uuid.UUID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *UserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddPassIDs adds the "passes" edge to the Pass entity by ids.
func (m *UserMutation) AddPassIDs(ids ...uuid.UUID) {
	if m.passes == nil {
		m.passes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.passes[ids[i]] = struct{}{}
	}
}

// ClearPasses clears the "passes" edge to the Pass entity.
func (m *UserMutation) ClearPasses() {
	m.clearedpasses = true
}

// PassesCleared reports if the "passes" edge to the Pass entity was cleared.
func (m *UserMutation) PassesCleared() bool {
	return m.clearedpasses
}

// RemovePassIDs removes the "passes" edge to the Pass entity by IDs.
func (m *UserMutation) RemovePassIDs(ids ...uuid.UUID) {
	if m.removedpasses == nil {
		m.removedpasses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.passes, ids[i])
		m.removedpasses[ids[i]] = struct{}{}
	}
}

// RemovedPasses returns the removed IDs of the "passes" edge to the Pass entity.
func (m *UserMutation) RemovedPassesIDs() (ids []uuid.UUID) {
	for id := range m.removedpasses {
		ids = append(ids, id)
	}
	return
}

// PassesIDs returns the "passes" edge IDs in the mutation.
func (m *UserMutation) PassesIDs() (ids []uuid.UUID) {
	for id := range m.passes {
		ids = append(ids, id)
	}
	return
}

// ResetPasses resets all changes to the "passes" edge.
func (m *UserMutation) ResetPasses() {
	m.passes = nil
	m.clearedpasses = false
	m.removedpasses = nil
}

// AddClubOwnerIDs adds the "club_owners" edge to the ClubOwner entity by ids.
func (m *UserMutation) AddClubOwnerIDs(ids ...uuid.UUID) {
	if m.club_owners == nil {
		m.club_owners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.club_owners[ids[i]] = struct{}{}
	}
}

// ClearClubOwners clears the "club_owners" edge to the ClubOwner entity.
func (m *UserMutation) ClearClubOwners() {
	m.clearedclub_owners = true
}

// ClubOwnersCleared reports if the "club_owners" edge to the ClubOwner entity was cleared.
func (m *UserMutation) ClubOwnersCleared() bool {
	return m.clearedclub_owners
}

// RemoveClubOwnerIDs removes the "club_owners" edge to the ClubOwner entity by IDs.
func (m *UserMutation) RemoveClubOwnerIDs(ids ...uuid.UUID) {
	if m.removedclub_owners == nil {
		m.removedclub_owners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.club_owners, ids[i])
		m.removedclub_owners[ids[i]] = struct{}{}
	}
}

// RemovedClubOwners returns the removed IDs of the "club_owners" edge to the ClubOwner entity.
func (m *UserMutation) RemovedClubOwnersIDs() (ids []uuid.UUID) {
	for id := range m.removedclub_owners {
		ids = append(ids, id)
	}
	return
}

// ClubOwnersIDs returns the "club_owners" edge IDs in the mutation.
func (m *UserMutation) ClubOwnersIDs() (ids []uuid.UUID) {
	for id := range m.club_owners {
		ids = append(ids, id)
	}
	return
}

// ResetClubOwners resets all changes to the "club_owners" edge.
func (m *UserMutation) ResetClubOwners() {
	m.club_owners = nil
	m.clearedclub_owners = false
	m.removedclub_owners = nil
}

// AddEventParticipantIDs adds the "event_participants" edge to the EventParticipant entity by ids.
func (m *UserMutation) AddEventParticipantIDs(ids ...uuid.UUID) {
	if m.event_participants == nil {
		m.event_participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.event_participants[ids[i]] = struct{}{}
	}
}

// ClearEventParticipants clears the "event_participants" edge to the EventParticipant entity.
func (m *UserMutation) ClearEventParticipants() {
	m.clearedevent_participants = true
}

// EventParticipantsCleared reports if the "event_participants" edge to the EventParticipant entity was cleared.
func (m *UserMutation) EventParticipantsCleared() bool {
	return m.clearedevent_participants
}

// RemoveEventParticipantIDs removes the "event_participants" edge to the EventParticipant entity by IDs.
func (m *UserMutation) RemoveEventParticipantIDs(ids ...uuid.UUID) {
	if m.removedevent_participants == nil {
		m.removedevent_participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.event_participants, ids[i])
		m.removedevent_participants[ids[i]] = struct{}{}
	}
}

// RemovedEventParticipants returns the removed IDs of the "event_participants" edge to the EventParticipant entity.
func (m *UserMutation) RemovedEventParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedevent_participants {
		ids = append(ids, id)
	}
	return
}

// EventParticipantsIDs returns the "event_participants" edge IDs in the mutation.
func (m *UserMutation) EventParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.event_participants {
		ids = append(ids, id)
	}
	return
}

// ResetEventParticipants resets all changes to the "event_participants" edge.
func (m *UserMutation) ResetEventParticipants() {
	m.event_participants = nil
	m.clearedevent_participants = false
	m.removedevent_participants = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.telegram_id != nil {
		fields = append(fields, user.FieldTelegramID)
	}
	if m.localization != nil {
		fields = append(fields, user.FieldLocalization)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.fio != nil {
		fields = append(fields, user.FieldFio)
	}
	if m.qr_payload != nil {
		fields = append(fields, user.FieldQrPayload)
	}
	if m.qr_file_id != nil {
		fields = append(fields, user.FieldQrFileID)
	}
	if m.is_banned != nil {
		fields = append(fields, user.FieldIsBanned)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldTelegramID:
		return m.TelegramID()
	case user.FieldLocalization:
		return m.Localization()
	case user.FieldUsername:
		return m.Username()
	case user.FieldRole:
		return m.Role()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFio:
		return m.Fio()
	case user.FieldQrPayload:
		return m.QrPayload()
	case user.FieldQrFileID:
		return m.QrFileID()
	case user.FieldIsBanned:
		return m.IsBanned()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldTelegramID:
		return m.OldTelegramID(ctx)
	case user.FieldLocalization:
		return m.OldLocalization(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFio:
		return m.OldFio(ctx)
	case user.FieldQrPayload:
		return m.OldQrPayload(ctx)
	case user.FieldQrFileID:
		return m.OldQrFileID(ctx)
	case user.FieldIsBanned:
		return m.OldIsBanned(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldTelegramID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegramID(v)
		return nil
	case user.FieldLocalization:
		v, ok := value.(user.Localization)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalization(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldRole:
		v, ok := value.(valueobject.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(valueobject.Email)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFio:
		v, ok := value.(valueobject.FIO)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFio(v)
		return nil
	case user.FieldQrPayload:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrPayload(v)
		return nil
	case user.FieldQrFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrFileID(v)
		return nil
	case user.FieldIsBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBanned(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtelegram_id != nil {
		fields = append(fields, user.FieldTelegramID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTelegramID:
		return m.AddedTelegramID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTelegramID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTelegramID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldQrPayload) {
		fields = append(fields, user.FieldQrPayload)
	}
	if m.FieldCleared(user.FieldQrFileID) {
		fields = append(fields, user.FieldQrFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldQrPayload:
		m.ClearQrPayload()
		return nil
	case user.FieldQrFileID:
		m.ClearQrFileID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldTelegramID:
		m.ResetTelegramID()
		return nil
	case user.FieldLocalization:
		m.ResetLocalization()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFio:
		m.ResetFio()
		return nil
	case user.FieldQrPayload:
		m.ResetQrPayload()
		return nil
	case user.FieldQrFileID:
		m.ResetQrFileID()
		return nil
	case user.FieldIsBanned:
		m.ResetIsBanned()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.owned_clubs != nil {
		edges = append(edges, user.EdgeOwnedClubs)
	}
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.ignore_mailings != nil {
		edges = append(edges, user.EdgeIgnoreMailings)
	}
	if m.notifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.passes != nil {
		edges = append(edges, user.EdgePasses)
	}
	if m.club_owners != nil {
		edges = append(edges, user.EdgeClubOwners)
	}
	if m.event_participants != nil {
		edges = append(edges, user.EdgeEventParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwnedClubs:
		ids := make([]ent.Value, 0, len(m.owned_clubs))
		for id := range m.owned_clubs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIgnoreMailings:
		ids := make([]ent.Value, 0, len(m.ignore_mailings))
		for id := range m.ignore_mailings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasses:
		ids := make([]ent.Value, 0, len(m.passes))
		for id := range m.passes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubOwners:
		ids := make([]ent.Value, 0, len(m.club_owners))
		for id := range m.club_owners {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventParticipants:
		ids := make([]ent.Value, 0, len(m.event_participants))
		for id := range m.event_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedowned_clubs != nil {
		edges = append(edges, user.EdgeOwnedClubs)
	}
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.removedignore_mailings != nil {
		edges = append(edges, user.EdgeIgnoreMailings)
	}
	if m.removednotifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.removedpasses != nil {
		edges = append(edges, user.EdgePasses)
	}
	if m.removedclub_owners != nil {
		edges = append(edges, user.EdgeClubOwners)
	}
	if m.removedevent_participants != nil {
		edges = append(edges, user.EdgeEventParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwnedClubs:
		ids := make([]ent.Value, 0, len(m.removedowned_clubs))
		for id := range m.removedowned_clubs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIgnoreMailings:
		ids := make([]ent.Value, 0, len(m.removedignore_mailings))
		for id := range m.removedignore_mailings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasses:
		ids := make([]ent.Value, 0, len(m.removedpasses))
		for id := range m.removedpasses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubOwners:
		ids := make([]ent.Value, 0, len(m.removedclub_owners))
		for id := range m.removedclub_owners {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventParticipants:
		ids := make([]ent.Value, 0, len(m.removedevent_participants))
		for id := range m.removedevent_participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedowned_clubs {
		edges = append(edges, user.EdgeOwnedClubs)
	}
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	if m.clearedignore_mailings {
		edges = append(edges, user.EdgeIgnoreMailings)
	}
	if m.clearednotifications {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.clearedpasses {
		edges = append(edges, user.EdgePasses)
	}
	if m.clearedclub_owners {
		edges = append(edges, user.EdgeClubOwners)
	}
	if m.clearedevent_participants {
		edges = append(edges, user.EdgeEventParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOwnedClubs:
		return m.clearedowned_clubs
	case user.EdgeEvents:
		return m.clearedevents
	case user.EdgeIgnoreMailings:
		return m.clearedignore_mailings
	case user.EdgeNotifications:
		return m.clearednotifications
	case user.EdgePasses:
		return m.clearedpasses
	case user.EdgeClubOwners:
		return m.clearedclub_owners
	case user.EdgeEventParticipants:
		return m.clearedevent_participants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOwnedClubs:
		m.ResetOwnedClubs()
		return nil
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	case user.EdgeIgnoreMailings:
		m.ResetIgnoreMailings()
		return nil
	case user.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case user.EdgePasses:
		m.ResetPasses()
		return nil
	case user.EdgeClubOwners:
		m.ResetClubOwners()
		return nil
	case user.EdgeEventParticipants:
		m.ResetEventParticipants()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
